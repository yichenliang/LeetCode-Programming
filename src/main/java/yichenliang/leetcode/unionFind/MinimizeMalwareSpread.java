package yichenliang.leetcode.unionFind;

import java.util.Arrays;

/**
 * 924. Minimize Malware Spread
 * 
 * union find
 * 
 * 
 */

public class MinimizeMalwareSpread {
	
//	class DSU {
//	    private int[] root;
//	    private int[] size;
//	    private int[] affected;
//	    public DSU(int n) {
//	        root = new int[n];
//	        affected = new int[n];
//	        for (int i = 0; i < n; i++) {
//	            root[i] = i;
//	        }
//
//	        size = new int[n];
//	        Arrays.fill(size, 1);
//	    }
//
//	    public int find(int x) {
//	        if (root[x] != x) {
//	            root[x] = find(root[x]);
//	        }
//	        return root[x];
//	    }
//
//	    public void union(int x, int y) {
//	        int rootX = find(x);
//	        int rootY = find(y);
//	        if (rootX == rootY) return;
//
//	        if (size[rootX] < size[rootY]) {
//	            root[rootX] = rootY;
//	            //size[rootY]++;
//	            size[rootY] += size[rootX];
//	        } else {
//	            root[rootY] = rootX;
//	            //size[rootX]++;
//	            size[rootX] += size[rootY];
//	        }
//	    }
//	}
//	
//	public int minMalwareSpread(int[][] graph, int[] initial) {
//		int n = graph.length;
//        Arrays.sort(initial);
//        DSU dsu = new DSU(n);
//
//        for (int i = 0; i < n; i++) {
//            for (int j = 0; j < n; j++) {
//                if (graph[i][j] == 1) {
//                    dsu.union(i, j);
//                }
//            }
//        }
//
//        for (int i : initial) {
//            int root = dsu.find(i);
//            dsu.affected[root]++;
//        }
//
//        int res = -1;
//        int num = 0;
//        for (int i : initial) {
//            int root = dsu.find(i);
//            if (dsu.affected[root] == 1) {
//                if (num < dsu.size[root]) {
//                    num = dsu.size[root];
//                    res = i;
//                }
//            }
//        }
//
//        return res == -1 ? initial[0] : res;		
//	}
	
	 public int minMalwareSpread(int[][] graph, int[] initial) {
	        int n = graph.length;
	        int[] root = new int[n];
	        int[] size = new int[n];
	        int[] affect = new int[n];
	        Arrays.sort(initial);
	        for(int i = 0; i < n; i++){
	            root[i] = i;
	        }
	        Arrays.fill(size, 1);
	        //union graph
	        for(int i = 0; i < n; i++){
	            for(int j = 0; j < n; j++){
	                if(graph[i][j] == 1) union(root, size, i, j);
	            }
	        }
	        
	        for(int each : initial){
	            int r = find(root, each);
	            affect[r]++;
	        }
	        
	        int res = -1;
	        int num = 0;
	        for(int i : initial){
	            int r = find(root, i);
	            if(affect[r] == 1 && num < size[r]){
	                num = size[r];
	                res = i;
	            }
	        }
	        
	        return res == -1 ? initial[0] : res;
	    }
	    
	    private void union(int[] root, int[] size, int i, int j){
	        int ri = find(root, i);
	        int rj = find(root, j);
	        if(ri == rj){
	            return;
	        }
	        else{
	            if(size[ri] > size[rj]){
	                size[ri] += size[rj];
	                root[rj] = root[ri];
	            }
	            else{
	               size[rj] += size[ri];
	               root[ri] = root[rj]; 
	            }
	        }
	        return;
	    }
	    
	    private int find(int[] root, int i){
	        if(root[i] != i){
	            return find(root, root[i]);
	        }
	        return i;
	    }

}
