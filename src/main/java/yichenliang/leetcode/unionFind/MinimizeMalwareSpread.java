package yichenliang.leetcode.unionFind;

import java.util.Arrays;

/**
 * 924. Minimize Malware Spread
 * 
 * union find
 * 
 * 
 */

public class MinimizeMalwareSpread {
	
	class DSU {
	    private int[] root;
	    private int[] size;
	    private int[] affected;
	    public DSU(int n) {
	        root = new int[n];
	        affected = new int[n];
	        for (int i = 0; i < n; i++) {
	            root[i] = i;
	        }

	        size = new int[n];
	        Arrays.fill(size, 1);
	    }

	    public int find(int x) {
	        if (root[x] != x) {
	            root[x] = find(root[x]);
	        }
	        return root[x];
	    }

	    public void union(int x, int y) {
	        int rootX = find(x);
	        int rootY = find(y);
	        if (rootX == rootY) return;

	        if (size[rootX] < size[rootY]) {
	            root[rootX] = rootY;
	            //size[rootY]++;
	            size[rootY] += size[rootX];
	        } else {
	            root[rootY] = rootX;
	            //size[rootX]++;
	            size[rootX] += size[rootY];
	        }
	    }
	}
	
	public int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
        Arrays.sort(initial);
        DSU dsu = new DSU(n);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    dsu.union(i, j);
                }
            }
        }

        for (int i : initial) {
            int root = dsu.find(i);
            dsu.affected[root]++;
        }

        int res = -1;
        int num = 0;
        for (int i : initial) {
            int root = dsu.find(i);
            if (dsu.affected[root] == 1) {
                if (num < dsu.size[root]) {
                    num = dsu.size[root];
                    res = i;
                }
            }
        }

        return res == -1 ? initial[0] : res;		
	}

}
